# Automatic Material Setup

This package provides a tool for automatically generating or overwriting a Material based on the `material.json` file.

![Auto-generate material](../_img/auto-generate-material.gif)

The results generated by this tool are for reference only. Some detailed properties, such as BackFaceUseUV2, etc., still need to be manually configured.

Double-clicking on the converted `material.json` file opens the `HSR Material Viewer`, which makes it easier to browse the contents of the `material.json` file.

![HSR Material Viewer](../_img/hsr-mat-viewer.gif)

## Tool Extension

After importing the `HSR.NPRShader.Editor.Automation` namespace, declare a class with a parameterless constructor derived from `BaseMaterialSetter`. The following members can be overridden:

### Properties

|Name|Description|
|:-|:-|
|Order|Priority. The smaller the number, the higher the priority.|
|SupportedShaderMap|Shader map supported by this class. Key is the Shader name in the game, and Value is the converted Shader name in the project.|

### Methods

The parameters passed in are the corresponding information in the `material.json` file, and the methods return a list of properties to be set on the Material.

|Name|Description|
|:-|:-|
|ApplyTextures|Set the Material's Texture properties.|
|ApplyInts|Set the Material's Int properties.|
|ApplyFloats|Set the Material's Float properties.|
|ApplyColors|Set the Material's Color properties.|

### Example

```csharp
public class FaceMaterialSetter : BaseMaterialSetter
{
    protected override IReadOnlyDictionary<string, string> SupportedShaderMap => new Dictionary<string, string>()
    {
        ["miHoYo/CRP_Character/CharacterFace"] = "Honkai Star Rail/Character/Face"
    };

    protected override IEnumerable<(string, TextureJsonData)> ApplyTextures(IReadOnlyDictionary<string, TextureJsonData> textures)
    {
        yield return ("_MainTex", textures["_MainTex"]);
        yield return ("_FaceMap", textures["_FaceMap"]);
        yield return ("_ExpressionMap", textures["_FaceExpression"]);
    }

    protected override IEnumerable<(string, float)> ApplyFloats(IReadOnlyDictionary<string, float> floats)
    {
        if (floats.TryGetValue("_UseUVChannel2", out float useUV2))
        {
            yield return ("_FaceMapUV2", useUV2);
        }

        yield return ("_EmissionThreshold", floats["_EmissionThreshold"]);
        yield return ("_EmissionIntensity", floats["_EmissionIntensity"]);

        yield return ("_NoseLinePower", floats["_NoseLinePower"]);

        yield return ("_mmBloomIntensity0", floats["_mBloomIntensity0"]);
    }

    protected override IEnumerable<(string, Color)> ApplyColors(IReadOnlyDictionary<string, Color> colors)
    {
        yield return ("_Color", colors["_Color"]);
        yield return ("_ShadowColor", colors["_ShadowColor"]);
        yield return ("_EyeShadowColor", colors["_EyeShadowColor"]);
        yield return ("_EmissionColor", Color.white);
        yield return ("_OutlineColor0", colors["_OutlineColor"]);
        yield return ("_NoseLineColor", colors["_NoseLineColor"]);

        // Texture Scale Offset
        yield return ("_Maps_ST", colors["_MainMaps_ST"]);

        // Expression
        yield return ("_ExCheekColor", colors["_ExCheekColor"]);
        yield return ("_ExShyColor", colors["_ExShyColor"]);
        yield return ("_ExShadowColor", colors["_ExShadowColor"]);
        yield return ("_ExEyeColor", colors["_ExEyeColor"]);
    }
}
```
